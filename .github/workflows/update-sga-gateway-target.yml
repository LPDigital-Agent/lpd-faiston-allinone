# =============================================================================
# SGA MCP Gateway Target Schema Update
# =============================================================================
# Updates the MCP Gateway Target with new tool definitions.
#
# This workflow is needed because the Gateway was created via boto3 (not Terraform)
# and uses inline tool schema that must be updated when new tools are added.
#
# Issue #17: Added schema introspection tools (sga_get_schema_metadata, etc.)
#
# AWS Account: 377311924364 (Faiston One)
# =============================================================================

name: Update SGA Gateway Target

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'update'
        type: choice
        options:
          - update
          - status

env:
  AWS_REGION: us-east-2
  GATEWAY_ID: faiston-one-sga-gateway-prod-qbnlm3ao63
  TARGET_ID: SKVZZNCDKE
  TARGET_NAME: SGAPostgresTools
  LAMBDA_ARN: arn:aws:lambda:us-east-2:377311924364:function:faiston-one-prod-sga-postgres-tools

jobs:
  update:
    name: Update Gateway Target Schema
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.action == 'update' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install dependencies
        run: pip install boto3 requests

      - name: Update Gateway Target
        run: |
          python3 << 'EOF'
          import boto3
          import json
          import os

          # Configuration
          GATEWAY_ID = os.environ["GATEWAY_ID"]
          TARGET_ID = os.environ["TARGET_ID"]
          TARGET_NAME = os.environ["TARGET_NAME"]
          LAMBDA_ARN = os.environ["LAMBDA_ARN"]
          REGION = os.environ["AWS_REGION"]

          # Complete tool schema with 11 tools (8 original + 3 schema introspection)
          TOOL_SCHEMA = [
              {
                  "name": "sga_list_inventory",
                  "description": "Lista ativos e saldos no estoque com filtros opcionais",
                  "inputSchema": {
                      "type": "object",
                      "properties": {
                          "location_id": {"type": "string", "description": "Filtro por código do local"},
                          "project_id": {"type": "string", "description": "Filtro por código do projeto"},
                          "part_number": {"type": "string", "description": "Filtro por part number"},
                          "status": {"type": "string", "enum": ["IN_STOCK", "IN_TRANSIT", "RESERVED", "INSTALLED"]},
                          "limit": {"type": "integer", "default": 100, "maximum": 1000},
                          "offset": {"type": "integer", "default": 0}
                      }
                  }
              },
              {
                  "name": "sga_get_balance",
                  "description": "Obtém saldo de estoque para um part number em um local",
                  "inputSchema": {
                      "type": "object",
                      "required": ["part_number"],
                      "properties": {
                          "part_number": {"type": "string", "description": "Part number a consultar"},
                          "location_id": {"type": "string", "description": "Filtro por local (opcional)"},
                          "project_id": {"type": "string", "description": "Filtro por projeto (opcional)"}
                      }
                  }
              },
              {
                  "name": "sga_search_assets",
                  "description": "Busca ativos por serial number, part number ou descrição",
                  "inputSchema": {
                      "type": "object",
                      "required": ["query"],
                      "properties": {
                          "query": {"type": "string", "description": "Termo de busca (serial, PN ou descrição)"},
                          "search_type": {"type": "string", "enum": ["serial", "part_number", "description", "all"], "default": "all"},
                          "limit": {"type": "integer", "default": 50}
                      }
                  }
              },
              {
                  "name": "sga_get_asset_timeline",
                  "description": "Obtém histórico completo de um ativo (event sourcing)",
                  "inputSchema": {
                      "type": "object",
                      "required": ["identifier"],
                      "properties": {
                          "identifier": {"type": "string", "description": "Asset ID ou serial number"},
                          "identifier_type": {"type": "string", "enum": ["asset_id", "serial_number"], "default": "serial_number"},
                          "limit": {"type": "integer", "default": 100}
                      }
                  }
              },
              {
                  "name": "sga_get_movements",
                  "description": "Lista movimentações com filtros por data, tipo e projeto",
                  "inputSchema": {
                      "type": "object",
                      "properties": {
                          "start_date": {"type": "string", "format": "date", "description": "Data inicial (YYYY-MM-DD)"},
                          "end_date": {"type": "string", "format": "date", "description": "Data final (YYYY-MM-DD)"},
                          "movement_type": {"type": "string", "enum": ["ENTRADA", "SAIDA", "TRANSFERENCIA", "RESERVA", "LIBERACAO", "AJUSTE_POSITIVO", "AJUSTE_NEGATIVO", "EXPEDIÇÃO", "REVERSA"]},
                          "project_id": {"type": "string"},
                          "location_id": {"type": "string"},
                          "limit": {"type": "integer", "default": 100}
                      }
                  }
              },
              {
                  "name": "sga_get_pending_tasks",
                  "description": "Lista tarefas pendentes de aprovação (HIL)",
                  "inputSchema": {
                      "type": "object",
                      "properties": {
                          "task_type": {"type": "string", "enum": ["APPROVAL_ENTRY", "APPROVAL_EXIT", "APPROVAL_ADJUSTMENT", "DIVERGENCE_RESOLUTION", "DOCUMENT_REVIEW", "QUALITY_CHECK"]},
                          "priority": {"type": "string", "enum": ["LOW", "MEDIUM", "HIGH", "URGENT"]},
                          "assignee_id": {"type": "string"},
                          "limit": {"type": "integer", "default": 50}
                      }
                  }
              },
              {
                  "name": "sga_create_movement",
                  "description": "Cria uma nova movimentação de estoque",
                  "inputSchema": {
                      "type": "object",
                      "required": ["movement_type", "part_number", "quantity"],
                      "properties": {
                          "movement_type": {"type": "string", "enum": ["ENTRADA", "SAIDA", "TRANSFERENCIA", "RESERVA", "LIBERACAO", "AJUSTE_POSITIVO", "AJUSTE_NEGATIVO"]},
                          "part_number": {"type": "string"},
                          "quantity": {"type": "integer", "minimum": 1},
                          "source_location_id": {"type": "string", "description": "Local de origem (para saída/transferência)"},
                          "destination_location_id": {"type": "string", "description": "Local de destino (para entrada/transferência)"},
                          "project_id": {"type": "string"},
                          "serial_numbers": {"type": "array", "items": {"type": "string"}, "description": "Lista de serial numbers"},
                          "nf_number": {"type": "string"},
                          "nf_date": {"type": "string", "format": "date"},
                          "reason": {"type": "string"}
                      }
                  }
              },
              {
                  "name": "sga_reconcile_sap",
                  "description": "Compara estoque SGA com dados exportados do SAP",
                  "inputSchema": {
                      "type": "object",
                      "required": ["sap_data"],
                      "properties": {
                          "sap_data": {
                              "type": "array",
                              "items": {
                                  "type": "object",
                                  "required": ["part_number", "quantity"],
                                  "properties": {
                                      "part_number": {"type": "string"},
                                      "quantity": {"type": "integer"},
                                      "location_code": {"type": "string"},
                                      "project_code": {"type": "string"}
                                  }
                              },
                              "description": "Lista de itens do SAP para reconciliação"
                          },
                          "include_serials": {"type": "boolean", "default": False}
                      }
                  }
              },
              # =============================================================================
              # Schema Introspection Tools (for NEXO Import schema-aware validation)
              # Added January 2026 - Issue #17
              # =============================================================================
              {
                  "name": "sga_get_schema_metadata",
                  "description": "Obtém metadados completos do schema PostgreSQL para validação de importação NEXO. Retorna tabelas, colunas, ENUMs, FKs e constraints.",
                  "inputSchema": {
                      "type": "object",
                      "properties": {}
                  }
              },
              {
                  "name": "sga_get_table_columns",
                  "description": "Obtém metadados das colunas de uma tabela específica do PostgreSQL.",
                  "inputSchema": {
                      "type": "object",
                      "required": ["table_name"],
                      "properties": {
                          "table_name": {"type": "string", "description": "Nome da tabela PostgreSQL"},
                          "schema_name": {"type": "string", "default": "sga", "description": "Schema PostgreSQL (default: sga)"}
                      }
                  }
              },
              {
                  "name": "sga_get_enum_values",
                  "description": "Obtém valores válidos de um ENUM PostgreSQL.",
                  "inputSchema": {
                      "type": "object",
                      "required": ["enum_name"],
                      "properties": {
                          "enum_name": {"type": "string", "description": "Nome do tipo ENUM PostgreSQL"}
                      }
                  }
              }
          ]

          print(f"=== Updating Gateway Target: {TARGET_NAME} ===")
          print(f"Gateway ID: {GATEWAY_ID}")
          print(f"Target ID: {TARGET_ID}")
          print(f"Tools to register: {len(TOOL_SCHEMA)}")

          # Create boto3 client for AgentCore Control
          # Note: The service name may vary - trying different names
          try:
              client = boto3.client("bedrock-agentcore-control", region_name=REGION)
          except Exception as e:
              print(f"bedrock-agentcore-control not available: {e}")
              print("Trying alternative service names...")

              # Try with requests directly to the API
              import requests
              from botocore.auth import SigV4Auth
              from botocore.awsrequest import AWSRequest

              session = boto3.Session()
              credentials = session.get_credentials().get_frozen_credentials()

              # AgentCore Control API endpoint
              api_url = f"https://bedrock-agentcore-control.{REGION}.amazonaws.com"

              # Update target endpoint
              update_url = f"{api_url}/gateways/{GATEWAY_ID}/targets/{TARGET_ID}"

              # Request body
              payload = {
                  "targetConfiguration": {
                      "lambda": {
                          "lambdaArn": LAMBDA_ARN,
                          "toolSchema": {
                              "inlinePayload": TOOL_SCHEMA
                          }
                      }
                  },
                  "credentialProviderConfigurations": [
                      {"credentialProviderType": "GATEWAY_IAM_ROLE"}
                  ]
              }

              body = json.dumps(payload)

              # Create and sign request
              request = AWSRequest(
                  method="PATCH",
                  url=update_url,
                  data=body,
                  headers={
                      "Content-Type": "application/json",
                      "Accept": "application/json"
                  }
              )

              SigV4Auth(credentials, "bedrock-agentcore-control", REGION).add_auth(request)

              print(f"\nSending PATCH to: {update_url}")
              print(f"Payload: {json.dumps(payload, indent=2)[:500]}...")

              response = requests.patch(
                  update_url,
                  headers=dict(request.headers),
                  data=body,
                  timeout=30
              )

              print(f"\nResponse Status: {response.status_code}")
              print(f"Response Body: {response.text}")

              if response.status_code in [200, 202]:
                  print("\n✅ Gateway Target updated successfully!")
                  result = response.json()
                  print(f"Target Name: {result.get('name', TARGET_NAME)}")
                  print(f"Tools: {len(TOOL_SCHEMA)}")
              else:
                  print("\n❌ Failed to update Gateway Target")
                  print(f"Error: {response.text}")
                  exit(1)
          EOF

      - name: Verify Target Update
        run: |
          echo "=== Verifying Gateway Target ==="

          # Test the Gateway endpoint with tools/list
          python3 << 'EOF'
          import boto3
          import json
          import requests
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest

          GATEWAY_ID = "faiston-one-sga-gateway-prod-qbnlm3ao63"
          REGION = "us-east-2"

          session = boto3.Session()
          credentials = session.get_credentials().get_frozen_credentials()

          # Gateway MCP endpoint
          gateway_url = f"https://{GATEWAY_ID}.gateway.bedrock-agentcore.{REGION}.amazonaws.com/mcp"

          # MCP tools/list request
          payload = {
              "jsonrpc": "2.0",
              "id": "verify-tools",
              "method": "tools/list",
              "params": {}
          }

          body = json.dumps(payload)

          request = AWSRequest(
              method="POST",
              url=gateway_url,
              data=body,
              headers={
                  "Content-Type": "application/json",
                  "Accept": "application/json"
              }
          )

          SigV4Auth(credentials, "bedrock-agentcore", REGION).add_auth(request)

          print(f"Calling tools/list on Gateway: {gateway_url}")

          response = requests.post(
              gateway_url,
              headers=dict(request.headers),
              data=body,
              timeout=30
          )

          if response.status_code == 200:
              result = response.json()
              tools = result.get("result", {}).get("tools", [])
              print(f"\n✅ Found {len(tools)} tools in Gateway:")
              for tool in tools:
                  print(f"  - {tool.get('name', 'unknown')}")

              # Check for schema tools
              schema_tools = [t for t in tools if "schema" in t.get("name", "").lower()]
              if len(schema_tools) >= 3:
                  print(f"\n✅ All 3 schema introspection tools present!")
              else:
                  print(f"\n⚠️ Only {len(schema_tools)} schema tools found")
          else:
              print(f"\n❌ Failed to list tools: {response.status_code}")
              print(f"Response: {response.text}")
          EOF

      - name: Summary
        run: |
          echo "## SGA Gateway Target Updated! :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Detail | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Gateway ID | \`${{ env.GATEWAY_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Target Name | \`${{ env.TARGET_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Target ID | \`${{ env.TARGET_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | \`${{ env.AWS_REGION }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**MCP Tools (11):**" >> $GITHUB_STEP_SUMMARY
          echo "- Data Operations (8): list_inventory, get_balance, search_assets, get_timeline, get_movements, pending_tasks, create_movement, reconcile_sap" >> $GITHUB_STEP_SUMMARY
          echo "- Schema Introspection (3): get_schema_metadata, get_table_columns, get_enum_values" >> $GITHUB_STEP_SUMMARY

  status:
    name: Check Gateway Target Status
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.action == 'status' }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install dependencies
        run: pip install boto3 requests

      - name: Check Gateway Status
        run: |
          python3 << 'EOF'
          import boto3
          import json
          import requests
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest

          GATEWAY_ID = "faiston-one-sga-gateway-prod-qbnlm3ao63"
          REGION = "us-east-2"

          session = boto3.Session()
          credentials = session.get_credentials().get_frozen_credentials()

          # Gateway MCP endpoint
          gateway_url = f"https://{GATEWAY_ID}.gateway.bedrock-agentcore.{REGION}.amazonaws.com/mcp"

          # MCP tools/list request
          payload = {
              "jsonrpc": "2.0",
              "id": "status-check",
              "method": "tools/list",
              "params": {}
          }

          body = json.dumps(payload)

          request = AWSRequest(
              method="POST",
              url=gateway_url,
              data=body,
              headers={
                  "Content-Type": "application/json",
                  "Accept": "application/json"
              }
          )

          SigV4Auth(credentials, "bedrock-agentcore", REGION).add_auth(request)

          print(f"=== Gateway Status Check ===")
          print(f"Gateway URL: {gateway_url}\n")

          response = requests.post(
              gateway_url,
              headers=dict(request.headers),
              data=body,
              timeout=30
          )

          if response.status_code == 200:
              result = response.json()
              tools = result.get("result", {}).get("tools", [])
              print(f"Total Tools: {len(tools)}")
              print("\nRegistered Tools:")
              for tool in sorted(tools, key=lambda t: t.get("name", "")):
                  name = tool.get("name", "unknown")
                  desc = tool.get("description", "")[:50]
                  print(f"  ✓ {name}")
                  print(f"    {desc}...")
          else:
              print(f"Error: {response.status_code}")
              print(f"Response: {response.text}")
          EOF
